

# ORM

## Tidy up

- Add idField support so that a pk doesn't have to be 'id'

## Relationships

### Parse include syntax

```js
// From
{
  related: 'comments, author, comments.author'
}

// To
[
  {
    name: 'comments',
    type: 'hasMany',
    modelFrom: Post,
    modelTo: Comment,
    keyFrom: 'id',
    keyTo: 'post_id',
    relations: [
      {
        name: 'author',
        type: 'belongsTo',
        modelFrom: Comment,
        modelTo: Author,
        keyFrom: 'author_id',
        keyTo: 'id',
        relations: []
      }
    ]
  },
  {
    name: 'author',
    type: 'belongsTo',
    modelFrom: Post,
    modelTo: Author,
    keyFrom: 'author_id',
    keyTo: 'id',
    relations: []
  }
]
```


### Perform additional queries for related data
```js
`SELECT * FROM post`

const postIds = posts.map(post => post.id)
const postComments = `SELECT * FROM comment WHERE post_id IN ${postIds.join(',')}`

const authorIds = comments.map(comment => comment.author_id)
const commentAuthors = `SELECT * FROM author WHERE id IN ${authorIds.join(',')}`

const authorIds = posts.map(post => post.author_id)
const postAuthors = `SELECT * FROM author WHERE id IN ${authorIds.join(',')}`
```

### Group up the data, put in map of arrays keyed by fk

```js
const postCommentsByFk = new Map()
for (const comment of postComments) {
  if (!postCommentsByFk.has(comment.post_id)) {
    postCommentsByFk.set(comment.post_id, [])
  }
  postCommentsByFk.get(comment.post_id).push(comment)
}
```

### Join up data into a single structure

```js
for (const comment of comments) {
  comment.author = commentAuthors.get(comment.author_id)
}

for (const post of posts) {
  post.comments = postCommentsByFk.get(post.id)
  post.author = postAuthors.get(post.author_id)
}
```

## Integrate pagination at route level
JSON API meta key should contain any pagination info



## Add Query builder

### Purpose
In between layer to allow more advanced querying for a specific model

```js
// Could be like:

this.store.rawQuery('post', {
  join: 'LEFT JOIN comments ON comment.post_id = post.id',
  where: ['title = ? AND description = ?', 'my title', 'my description']
  limit: 10,
  offset: 2,
  orderBy: 'title DESC'
})

// or

this.store.modelQuery('post')
  .leftJoin('comment', 'post.id', 'comment.post_id')
  .where('first_name', 'Jo')
```


## Add raw data querying
Raw layer to allow advanced querying and returning non model free form data

```js
this.store.rawQuery('SELECT * FROM post WHERE title = ?', ['My Post Title'])
```

# Route

this.store.findAll('post')

# Store

## findAll
const Post = this.modelFor('post')
const PostAdapter = this.adapterFor('post')
const PostSerializer = this.serializerFor('post')
const posts = await PostAdapter.findAll(Post)
return PostSerializer.serialize(Post, posts)

## modelFor
return Registry.modelByName('post')

## adapterFor
- app/adapters/post.js
- app/adapters/application.js
- default adapter (postgres)

## serializerFor
- app/serializers/post.js
- app/serializers/application.js
- default serializer (jsonapi)

# Adapter

## findAll
const attributes = this.fieldsFromAttributes(Model.attributes)
const tableName = Model.tableName
return this.knex.column(attributes).select().from(tableName)

# Serializer

## serialize
const serialize = require('loopback-jsonapi-model-serializer')
const config = require()
return serialize(posts, Post, {baseUrl: config.baseUrl})


# 3 layers of data access (proposal)

## Model methods: (layer 3)
These mirror ember data methods. They are high level and aim to be
useable by the API via the url query string etc. They follow jsonapi
spec where appliable.
They are:

### findAll
```js
this.store.findAll('post') // returns all posts
```

### query
```js
this.store.query('post', {
  include: 'comments, author',
  fields: {
    post: 'title',
    comments: 'comment',
    author: 'firstName, lastName'
  },
  sort: '-title',
  page: {number: 1, size: 20},
  filter: {
    title: {$like: '%tips for%'},
    id: {$gt: 10}
  }
}) // returns posts based on various criteria
```

### findRecord
```js
this.store.findRecord('post', 1) // returns a single post by id
```

### queryRecord
```js
this.store.queryRecord('post', options) // returns a single query, otherwise same as .query
```

## Model querying: (layer 2)
This is a single method that allows for building more advanced queries.

This type of querying allows for more advanced scenarios querying
accross multiple tables via joins etc while still allowing Ash to help
you out by building model objects from the returned data for you.

Eg.
```js
this.store.modelQuery('post')
  .leftJoin('author', 'post.author_id', 'author.id')
  .where('author.first_name', 'Jo')
```

## Raw sql querying: (layer 1)
There will
undoubtedly be scenarios that fall outside the scope of full ORM queries
or even the more advanced modelQueries. This single method allows for
building raw sql queries that
will return the raw data for you to handle as you like.

```js
this.store.rawQuery('SELECT * FROM post WHERE title = ?', ['My Post Title'])
```

# Models

## Defining a model

```js
class Post extends Model {
  static attributes (attr) {
    attr('title', 'string')
    attr('description', 'string')
  }

  static relationships (relation) {
    relation('comments', 'hasMany') // assumes fk details
    relation('author', 'belongsTo', 'author_id', 'id') // explicit fk details
  }
}
```

## Creating a model instance

Typically this will not be an operation performed by the end user of the framework. The developer
is expected to interface with the stores methods such as:

```js
this.store.createRecord('post', {title: 'my title', description: 'my description', author_id: 1})
```

Under the hood however, the following operation will be performed by the store

```js
const post = new Post({title: 'my title', description: 'my description', author_id: 1})
```

This attribute data will be stored in whole under the key `post.attributes` but the model has getters
and setters for the attributes such that `post.title` will return `post.attributes.title` etc

Methods are also defined for relationships such that in the example above a call to `post.comments()`
will return a promise that will resolve to an array of comment models fetched as a separate query
to the database. These comments are then cached on `post.attributes.comments` so that any subsequent
calls to `post.comments()` will return a promise that immediately resolves with `post.attributes.comments`

## Creating a model instance with relationship data

Again, from the end developers POV this operation is to be performed via the store

```js
const post = this.store.createRecord('post', {
  title: 'my title',
  description: 'my description',
  author: {
    firstName: 'Jo',
    lastName: 'Bloggs'
  },
  comments: [{
    comment: 'This is a comment'
  }]
})

post.save() // to save just the post
post.saveAll() //  to bulk save the post and its related data inside a transaction
```

Under the hood the following is happening
```js
// this.store.createRecord creates a model instance and returns post instance
const post = new Post({
  title: 'my title',
  description: 'my description',
  author: {
    firstName: 'Jo',
    lastName: 'Bloggs'
  },
  comments: [{
    comment: 'This is a comment'
  }]
})

// post.save or post.saveAll uses the adapter's createRecord method
adapter.createRecord(Post, post)

// and then updates the fk's on the instance (and it's relationship data if applicable)
```

## Fetching data

### Basic case with findAll

Via the store:
```js
this.store.findAll('post')
```

Behind the scenes in the findAll method:
```js
const Post = this.modelFor('post')
const adapter = this.adapterFor('post')
const results = await adapter.findAll(Post) // to get the data

// iterates over the data from the adapter and creates models
results.map(data => new Post(data))
```

### Side loading with query

```js
this.store.query('post', {include: 'comments'})
```

Behind the scenes in the query method now multiple data fetches need to happen
(probably in a transaction?)
We need to fetch the posts as in the findAll case but then we need to process out the
ids of the posts fetched and pass them to a query for comments

```js
const postIds = results.map(data => data.id)
const comments = await adapter.query('comments', {post_id: {$in: postIds}})
```

And then we need to massage the comments a bit

```js
const postCommentsByFk = new Map()
for (const comment of postComments) {
  // initialize a new bucket if we don't have one for this post_id yet
  if (!postCommentsByFk.has(comment.post_id)) {
    postCommentsByFk.set(comment.post_id, [])
  }
  // push the comment into the correct post_id bucket
  postCommentsByFk.get(comment.post_id).push(comment)
}
```

And then we need to zip the results of both queries together

```js
const zipped = posts.map(post => {
  post.comments = postCommentsByFk[post.id]
})
```


```js
zipped.map(data => new Post(data))
```
