'use strict';

var _ = require('lodash');
var url = require('url');

module.exports = function () {
  var options = arguments.length <= 0 || arguments[0] === undefined ? { baseUrl: '/' } : arguments[0];

  function primaryKeyForModel(model) {
    return model.getIdName();
  }

  function pluralForModel(model) {
    return model.pluralModelName;
  }

  function cleanUrl(urlString) {
    return url.format(url.parse(urlString));
  }

  function buildResourceLinks(data, model) {
    var pk = data[primaryKeyForModel(model)];
    var type = pluralForModel(model);
    var baseUrl = cleanUrl(options.baseUrl);
    return { self: '' + baseUrl + type + '/' + pk };
  }

  function buildRelationships(data, model) {
    var relationshipLinks = relationshipLinksFromData(data, model);
    var relationshipData = relationshipDataFromData(data, model);
    return _.merge(relationshipLinks, relationshipData);
  }

  function buildAttributes(data, model) {
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var attributeNames = attributesForModel(model, opts);
    return attributesFromData(data, attributeNames);
  }

  function relationshipLinksFromData(data, model) {
    var pk = data[primaryKeyForModel(model)];
    var type = pluralForModel(model);
    var relations = model.relations;
    var baseUrl = cleanUrl(options.baseUrl);

    var relationships = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(relations)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        relationships[name] = { links: { related: '' + baseUrl + type + '/' + pk + '/' + name } };
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return relationships;
  }

  function relatedModelFromRelation(relation) {
    if (!relation.polymorphic) {
      return relation.modelTo;
    } else {
      // polymorphic
      // can't know up front what modelTo is.
      // need to do a lookup in the db using discriminator
      // const discriminator = relation.polymorphic.discriminator
      // const name = relation.name
    }
  }

  function relationshipDataFromData(data, model) {
    var relations = model.relations;
    var relationships = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Object.keys(relations)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var name = _step2.value;

        var relation = relations[name];
        var relatedModel = relatedModelFromRelation(relation);
        if (relation.polymorphic) continue;
        var pk = primaryKeyForModel(relatedModel);
        var type = pluralForModel(relatedModel);
        if (Array.isArray(data[name])) {
          relationships[name] = { data: [] };
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = data[name][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var relatedData = _step3.value;

              relationships[name].data.push({ type: type, id: relatedData[pk] });
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } else if (data[name]) {
          relationships[name] = { data: { type: type, id: data[name][pk] } };
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return relationships;
  }

  function attributesForModel(model) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var attributes = _.clone(model.definition.properties);
    if (opts.primaryKey === false) delete attributes[primaryKeyForModel(model)];
    if (opts.foreignKeys === false) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = foreignKeysForModel(model)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var foreignKey = _step4.value;

          delete attributes[foreignKey];
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    return Object.keys(attributes);
  }

  function foreignKeysForModel(model) {
    var relations = model.relations;
    var keys = [];
    Object.keys(relations).filter(function (relationName) {
      return relations[relationName].type === 'belongsTo';
    }).forEach(function (relationName) {
      keys.push(relations[relationName].keyFrom);
      if (relations[relationName].polymorphic) {
        keys.push(relations[relationName].polymorphic.discriminator);
      }
    });
    return keys;
  }

  function attributesFromData(data, attributes) {
    var obj = {};
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = attributes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var attr = _step5.value;
        obj[attr] = data[attr];
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    return obj;
  }

  return {
    primaryKeyForModel: primaryKeyForModel,
    pluralForModel: pluralForModel,
    buildResourceLinks: buildResourceLinks,
    buildRelationships: buildRelationships,
    buildAttributes: buildAttributes,
    relationshipLinksFromData: relationshipLinksFromData,
    relationshipDataFromData: relationshipDataFromData,
    attributesForModel: attributesForModel,
    attributesFromData: attributesFromData,
    foreignKeysForModel: foreignKeysForModel,
    relatedModelFromRelation: relatedModelFromRelation
  };
};